name: Release Workflow

on:
  push:
    branches:
      - main
      - qt6-cmake-version  # Testing branch
    tags:
      - 'v*.*.*'  # Semantic version tags (v1.0.0, v2.1.3, etc.)

jobs:
  build:
    name: Build
    runs-on: ${{ matrix.os }}
    strategy:
      fail-fast: false  # Do not fail fast to ensure independent platform builds
      matrix:
        include:
          - os: ubuntu-22.04
            host: linux
            arch: gcc_64
          - os: macos-latest
            host: mac
            arch: clang_64
          - os: windows-latest
            host: windows
            arch: win64_msvc2019_64

    steps:
      - name: Checkout repository
        uses: actions/checkout@v4
        with:
          submodules: recursive
          fetch-depth: 0
      
      - name: Validate submodules
        run: |
          # Fail fast if submodules are not properly initialized
          if [ ! -f "qml-box2d/CMakeLists.txt" ]; then
            echo "ERROR: qml-box2d submodule not properly initialized"
            exit 1
          fi
          echo "Submodules validated successfully"
        shell: bash

      - name: Cache Qt
        id: cache-qt
        uses: actions/cache@v4
        with:
          path: |
            ${{ github.workspace }}/Qt
            ~/.cache/pip
          key: ${{ runner.os }}-qt-6.5.2-${{ matrix.arch }}
          restore-keys: |
            ${{ runner.os }}-qt-6.5.2-
            ${{ runner.os }}-qt-

      - name: Cache CMake build directory
        uses: actions/cache@v4
        with:
          path: |
            build
            ~/.cache/cmake
          key: ${{ runner.os }}-cmake-${{ hashFiles('**/CMakeLists.txt', '**/cmake/**') }}
          restore-keys: |
            ${{ runner.os }}-cmake-

      - name: Cache vcpkg (if added later)
        uses: actions/cache@v4
        with:
          path: |
            vcpkg
            ~/.cache/vcpkg
          key: ${{ runner.os }}-vcpkg-${{ hashFiles('**/vcpkg.json', '**/vcpkg-configuration.json') }}
          restore-keys: |
            ${{ runner.os }}-vcpkg-

      - name: Setup MSVC environment (Windows only)
        if: matrix.host == 'windows'
        uses: microsoft/setup-msbuild@v2

      - name: Install Qt 6.5
        uses: jurplel/install-qt-action@v3
        with:
          version: '6.5.2'
          host: ${{ matrix.host }}
          target: 'desktop'
          arch: ${{ matrix.arch }}
          modules: 'qt5compat qtshadertools'

      - name: Install dependencies (Linux)
        if: runner.os == 'Linux'
        run: |
          sudo apt-get update
          sudo apt-get install -y ninja-build cmake libgl1-mesa-dev libxkbcommon-x11-0 libxcb-icccm4 libxcb-image0 libxcb-keysyms1 libxcb-randr0 libxcb-render-util0 libxcb-xinerama0 libfontconfig1
          # Use AppImageTool instead of linuxdeployqt to avoid glibc issues
          wget -c "https://github.com/AppImage/AppImageKit/releases/download/continuous/appimagetool-x86_64.AppImage"
          chmod +x appimagetool-x86_64.AppImage
          sudo mv appimagetool-x86_64.AppImage /usr/local/bin/appimagetool
          # Install fuse for AppImage support
          sudo apt-get install -y fuse libfuse2

      - name: Install dependencies (macOS)
        if: runner.os == 'macOS'
        run: |
          brew install ninja cmake

      - name: Install dependencies (Windows)
        if: runner.os == 'Windows'
        run: |
          choco install ninja cmake
        shell: pwsh

      - name: Verify Qt installation
        run: |
          echo "Qt6_DIR: $Qt6_DIR"
          echo "CMAKE_PREFIX_PATH: $CMAKE_PREFIX_PATH"
          echo "PATH: $PATH"
        shell: bash

      - name: Build application
        run: |
          echo "Building application on ${{ matrix.os }}"
          mkdir -p build
          cd build
          cmake .. -G Ninja -DCMAKE_BUILD_TYPE=Release
          cmake --build . --parallel
        shell: bash

      - name: Run tests
        if: success()
        run: |
          cd build
          ctest --output-on-failure

      - name: Deploy Qt runtime (Linux)
        if: success() && runner.os == 'Linux'
        run: |
          # Create AppDir structure manually
          mkdir -p BubblesApp.AppDir/usr/bin
          mkdir -p BubblesApp.AppDir/usr/lib
          mkdir -p BubblesApp.AppDir/usr/share/applications
          mkdir -p BubblesApp.AppDir/usr/share/icons/hicolor/256x256/apps
          
          # Copy executable
          cp build/BubblesApp BubblesApp.AppDir/usr/bin/
          
          # Create a simple icon (fallback)
          convert -size 256x256 xc:blue -fill white -gravity center -pointsize 48 -annotate +0+0 "Bubbles" BubblesApp.AppDir/BubblesApp.png || {
            # If ImageMagick is not available, create a simple text file as icon placeholder
            touch BubblesApp.AppDir/BubblesApp.png
          }
          
          # Copy Qt libraries
          export QTDIR=$Qt6_DIR
          export PATH=$Qt6_DIR/bin:$PATH
          
          # Use ldd to find and copy Qt libraries
          ldd build/BubblesApp | grep qt | awk '{print $3}' | xargs -I {} cp {} BubblesApp.AppDir/usr/lib/ || true
          
          # Create .desktop file
          cat > BubblesApp.AppDir/BubblesApp.desktop << EOF
          [Desktop Entry]
          Type=Application
          Name=BubblesApp
          Exec=BubblesApp
          Icon=BubblesApp
          Categories=Game;
          EOF
          
          # Create AppRun script
          cat > BubblesApp.AppDir/AppRun << 'EOF'
          #!/bin/bash
          HERE="$(dirname "$(readlink -f "${0}")")"
          export LD_LIBRARY_PATH="${HERE}/usr/lib:${LD_LIBRARY_PATH}"
          exec "${HERE}/usr/bin/BubblesApp" "$@"
          EOF
          chmod +x BubblesApp.AppDir/AppRun
          
          # Create AppImage using appimagetool
          export ARCH=x86_64
          appimagetool BubblesApp.AppDir BubblesApp-x86_64.AppImage
        shell: bash

      - name: Deploy Qt runtime (macOS)
        if: success() && runner.os == 'macOS'
        run: |
          export QTDIR=$Qt6_DIR
          export PATH=$Qt6_DIR/bin:$PATH
          
          # Create a self-signed certificate for ad-hoc signing
          security create-keychain -p "" build.keychain
          security default-keychain -s build.keychain
          security unlock-keychain -p "" build.keychain
          
          # Create a self-signed certificate
          cat > cert.conf << EOF
          [ req ]
          default_bits = 2048
          distinguished_name = req_distinguished_name
          req_extensions = v3_req
          prompt = no
          
          [ req_distinguished_name ]
          C = US
          ST = State
          L = City
          O = BubblesApp
          OU = Development
          CN = BubblesApp Developer
          
          [ v3_req ]
          keyUsage = keyEncipherment, dataEncipherment
          extendedKeyUsage = codeSigning
          EOF
          
          # Generate certificate
          openssl req -new -x509 -days 365 -nodes -out cert.pem -keyout key.pem -config cert.conf
          
          # Import certificate to keychain
          security import cert.pem -k build.keychain -T /usr/bin/codesign
          security import key.pem -k build.keychain -T /usr/bin/codesign
          security set-key-partition-list -S apple-tool:,apple: -s -k "" build.keychain
          
          # Run macdeployqt
          macdeployqt build/BubblesApp.app -qmldir=. -verbose=2
          
          # Sign the app bundle with ad-hoc signature
          codesign --force --deep --sign - build/BubblesApp.app
          
          # Verify the signature
          codesign --verify --verbose build/BubblesApp.app
          
          # Create DMG
          hdiutil create -volname "BubblesApp" -srcfolder build/BubblesApp.app -ov -format UDZO BubblesApp.dmg
          
          # Clean up keychain
          security delete-keychain build.keychain || true
        shell: bash

      - name: Deploy Qt runtime (Windows)
        if: success() && runner.os == 'Windows'
        run: |
          $env:PATH = "$env:Qt6_DIR\bin;$env:PATH"
          # Create deployment directory
          New-Item -ItemType Directory -Force -Path "deploy"
          Copy-Item "build\BubblesApp.exe" "deploy\"
          # Deploy Qt dependencies
          windeployqt --qmldir . --release --force deploy\BubblesApp.exe
          # Copy any additional DLLs that might be missed
          Get-ChildItem "build\*.dll" -ErrorAction SilentlyContinue | Copy-Item -Destination "deploy\"
        shell: pwsh

      - name: Package artifacts
        if: success()
        shell: bash
        run: |
          VERSION=${{ github.ref_name }}  # falls back to SHA on branch builds
          case "${{ runner.os }}" in
            Linux)   tar -czf Bubbles-${VERSION}-linux.tar.gz  Bubbles*.AppImage ;;
            macOS)   mv BubblesApp.dmg Bubbles-${VERSION}-mac.dmg ;;
            Windows) 7z a Bubbles-${VERSION}-windows.zip deploy/* ;;
          esac

      - name: Upload build artifacts
        if: success()
        uses: actions/upload-artifact@v4
        with:
          name: Bubbles-${{ github.ref_name }}-${{ matrix.host }}
          path: |
            Bubbles-*.tar.gz
            Bubbles-*.dmg
            Bubbles-*.zip

  create_release:
    name: Create Release
    runs-on: ubuntu-latest
    needs: build
    if: startsWith(github.ref, 'refs/tags/v')  # Only run on tagged commits

    steps:
      - name: Checkout repository
        uses: actions/checkout@v4
        with:
          submodules: true
          fetch-depth: 0

      - name: Download all build artifacts
        uses: actions/download-artifact@v4
        with:
          path: artifacts/

      - name: Prepare release assets
        run: |
          echo "Preparing release assets for release"
          ls -la artifacts/
          # Move all archives to root level for easier access
          find artifacts/ -name "*.tar.gz" -exec mv {} . \;
          find artifacts/ -name "*.dmg" -exec mv {} . \;
          find artifacts/ -name "*.zip" -exec mv {} . \;
          ls -la *.tar.gz *.dmg *.zip 2>/dev/null || echo "Some file types may not exist"

      - name: Create GitHub Release
        uses: softprops/action-gh-release@v1
        with:
          tag_name: ${{ github.ref }}
          files: |
            *.tar.gz
            *.dmg
            *.zip
          generate_release_notes: true
          draft: false
          prerelease: false
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
